[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Demo Quarto Page",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "shinylive.html",
    "href": "shinylive.html",
    "title": "Loading files in Shinylive apps in Quarto",
    "section": "",
    "text": "The following application shows three different ways of adding files to a Shinylive app embedded in a Quarto document.\nThe first is a text file embedded in the code block, like this:\n```{shinylive-python}\n## file: fruit.csv\nid,name,count\n1,\"apple\",20\n2,\"orange\",12\n3,\"grape\",100\n```\nThe second is a binary file embedded in the code block.\n```{shinylive-python}\n## file: fruit.pickle\n## type: binary\ngASVVAAAAAAAAABdlCh9lCiMAmlklEsEjARuYW1llIwEcGVhcpSMBWNvdW50lEsIdX2UKGgCSwVoA4wGYmFuYW5hlGgFSwZ1fZQoaAJLBmgDjARwbHVtlGgFSwt1ZS4=\n```\nThe third is a text file that is deployed as part of the Quarto-generated website, and loaded via http request, by using pyodide.http.pyfetch(). Note that pyodide.http.pyfetch() will only work in Shinylive; a normal Shiny deployment will not have pyodide available. If you want to abstract the code so that you can use the same function in both normal Shiny and Shinylive, see the get_url() function in this download demo app.\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: vertical\n#| viewerHeight: 400\n## file: app.py\nfrom pathlib import Path\nfrom os.path import dirname\nimport pickle as pkl\nfrom shiny import App, render, ui, Inputs, Outputs, Session\n\nappdir = Path(__file__).parent\n\napp_ui = ui.page_fluid(\n    ui.row(\n        ui.h4(\"Embedded CSV:\"),\n        ui.output_text_verbatim(\"embedded_csv\"),\n        ui.h4(\"Embedded pickle file:\"),\n        ui.output_text_verbatim(\"embedded_pickle\"),\n        ui.h4(\"Downloaded CSV:\"),\n        ui.output_text_verbatim(\"download_csv\"),\n    )\n)\n\n\ndef server(input: Inputs, output: Outputs, session: Session):\n    @output\n    @render.text\n    def embedded_csv():\n        with open(appdir / \"fruit.csv\", \"r\") as file:\n            content = file.read()\n        return content\n\n    @output\n    @render.text\n    def embedded_pickle():\n        with open(appdir / \"fruit.pickle\", \"rb\") as file:\n            data = pkl.load(file)\n        return str(data)\n\n    @output\n    @render.text\n    async def download_csv():\n        file_url = dirname(dirname(get_current_url(input))) + \"/fruit_data.csv\"\n        resp = await fetch_url(file_url)\n        return str(resp)\n\n\napp = App(app_ui, server)\n\n\ndef get_current_url(input: Inputs) -&gt; str:\n    return (\n        input[\".clientdata_url_protocol\"]()\n        + \"//\"\n        + input[\".clientdata_url_hostname\"]()\n        + \":\"\n        + input[\".clientdata_url_port\"]()\n        + input[\".clientdata_url_pathname\"]()\n    )\n\n\nasync def fetch_url(url: str, type: str = \"string\"):\n    import pyodide.http\n\n    response = await pyodide.http.pyfetch(url)\n\n    if type == \"json\":\n        # .json() parses the response as JSON and converts to dictionary.\n        return await response.json()\n    elif type == \"string\":\n        # .string() returns the response as a string.\n        return await response.string()\n    elif type == \"bytes\":\n        # .bytes() returns the response as a byte object.\n        return await response.bytes()\n    else:\n        return None\n\n## file: fruit.csv\nid,name,count\n1,\"apple\",20\n2,\"orange\",12\n3,\"grape\",100\n\n## file: fruit.pickle\n## type: binary\ngASVVAAAAAAAAABdlCh9lCiMAmlklEsEjARuYW1llIwEcGVhcpSMBWNvdW50lEsIdX2UKGgCSwVoA4wGYmFuYW5hlGgFSwZ1fZQoaAJLBmgDjARwbHVtlGgFSwt1ZS4="
  }
]